#ifndef PCSC_CENXFS_BRIDGE_Settings_H
#define PCSC_CENXFS_BRIDGE_Settings_H

#pragma once

#include <string>

class Settings
{
public:
    /// Содержит настройки для обхода всяческих проблем.
    class Workarounds {
    public:
        /// Содержит настройки для эмулирования второй дорожки.
        class Track2 {
        public:
            /** Сообщать XFS менеджеру о возможности читать track2. Kalignite падает, если считыватель
                не умеет читать вторую магнитную дорожку, так что для него этот параметр обязателен.
            @par Эффект
                Если задано, то при опросе возможностей устройства сообщается, что устройство умеет читать
                вторую дорожку. Кроме этого начинает действовать настройка `value`, содержащая значение
                второй дорожки, как оно будет соощено XFS-менеджеру.
            @par Значение по умолчанию
                По умолчанию настройка выключена, т.е. XFS-менеджеру сообщается, что чтение второй
                дорожки не поддерживается.
            */
            bool report;
            /** Значение второй дорожки, как она будет сообщена XFS менеджеру. Это означает, что она
                не должна содержать начального и конечного разделителей. Данное значение используется
                только в том случае, если `report` равно `true`.
            @par Значение по умолчанию
                По умолчанию содержит пустую строку, что означает, что при опросе данных дорожки чтение
                окончится со статусом `WFS_IDC_DATAMISSING`.
            */
            std::string value;
        public:
            Track2() : report(false) {}
        };
    public:
        /** Kalignite по какой-то причине при выбранном протоколе общения T0 посылает команды на
            передачу чипу данных по протоколу T1, добавляя в конец байт с количеством ожидаемых в
            ответе байт (в экспериментах там всегда был 0, т.е. ожидается 256 байт). Однако передача
            такого буфера SCardTransmit приводит к тому, что она возвращает код ошибки 0x57, что
            означает некорректные данные в буфере.
        @par Эффект
            Если данная настройка включена, то все передаваемые данные по протоколу T0 анализируется
            и в случае необходимости, длина данных корректируется таким образом, чтобы отсечь лишние
            байты.
        @par Значение по умолчанию
            По умолчанию настройка выключена, т.е. анализ не производится.
        */
        bool correctChipIO;
        /** Функционал извлечения карты объявлен обязательным к реализации, но предусмотривается, что
            он может отсутствовать у считывателя. В таком случае на команду извлечения карты нужно
            вернуть код ответа, сообщающий, что такая команда не поддерживается. Kalignite, однако,
            не ожидает такого кода ответа, хотя в возможностях устройства явно сказано, что извлечение
            карты не поддерживается.
        @par Эффект
            Если данная настройка включена, то команда на выдачу карты всегда успешна.
        @par Значение по умолчанию
            По умолчанию настройка выключена, т.е. в ответ на команду выдачи дается код ответа "Не поддерживается".
        */
        bool canEject;
        /// Kalignite требует, чтобы считыватель умел читать треки 2, поэтому мы имеем
        /// такую настройку.
        Track2 track2;
    public:
        Workarounds() : correctChipIO(false) {}
    };
public:
    /// Название самого провайдера.
    std::string providerName;
    /// Название считывателя, с которым должен работать провайдер.
    std::string readerName;
    /// Уровень подробности выводимых сообщений, чем выше, тем подробнее.
    /// Уровень 0 -- сообщения не выводятся.
    int traceLevel;
    /** Если `true`, то при открытии соединения с картой она открывается в монопольном режиме.
    @par Значение по умолчанию
        По умолчанию монопольный режим не используется.
    */
    bool exclusive;
    /// Настройки, касающиеся обхода багов реализации XFS подсистемы в Kalignite.
    Workarounds workarounds;
public:
    Settings(const char* serviceName, int traceLevel);

    std::string toJSONString() const;
};

#endif // PCSC_CENXFS_BRIDGE_Settings_H